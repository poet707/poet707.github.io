<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Radius-Based City Verification Map Tool</title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<style>
		body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 0; background: #f7f7f8; color: #111; }
		header { padding: 16px 20px; background: #fff; border-bottom: 1px solid #e6e6e6; position: sticky; top: 0; z-index: 2; }
		h1 { font-size: 18px; margin: 0; }
		main { display: grid; grid-template-columns: 360px 1fr; gap: 16px; padding: 16px; }
		@media (max-width: 980px) { main { grid-template-columns: 1fr; } }
		.card { background: #fff; border: 1px solid #e6e6e6; border-radius: 10px; padding: 12px; }
		.field { margin-bottom: 12px; }
		label { display: block; font-size: 12px; color: #555; margin-bottom: 6px; }
		input[type="text"], select, textarea {
			width: 100%; padding: 10px; border: 1px solid #dcdcdc; border-radius: 8px; font-size: 14px; box-sizing: border-box; background: #fff;
		}
		textarea { min-height: 120px; resize: vertical; }
		.actions { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
		button {
			appearance: none; border: 1px solid #1f64ff; background: #1f64ff; color: #fff; padding: 10px 14px;
			border-radius: 8px; font-weight: 600; cursor: pointer;
		}
		button.secondary { background: #fff; color: #1f64ff; }
		.subtle { font-size: 12px; color: #666; }
		#map { width: 100%; height: 70vh; min-height: 420px; border-radius: 10px; }
		.badge { display: inline-block; padding: 2px 8px; border-radius: 999px; font-size: 12px; border: 1px solid #e2e2e2; }
		.badge.ok { background: #e9f9ee; color: #0f7b3e; border-color: #bfe8cf; }
		.badge.no { background: #fdeceb; color: #a3312e; border-color: #f1c6c3; }
		table { width: 100%; border-collapse: collapse; font-size: 14px; }
		th, td { border-bottom: 1px solid #eee; padding: 8px; text-align: left; }
		th { font-size: 12px; color: #555; text-transform: uppercase; letter-spacing: .02em; }
		tfoot td { font-weight: 600; }
		.row-error { color: #a3312e; font-size: 12px; }
		.spinner { width: 16px; height: 16px; border: 2px solid #e0e7ff; border-top-color: #1f64ff; border-radius: 50%; animation: spin 0.8s linear infinite; display: inline-block; vertical-align: -3px; }
		@keyframes spin { to { transform: rotate(360deg); } }
	</style>
</head>
<body>
	<header><h1>Radius-Based City Verification Map Tool</h1></header>
	<main>
		<section class="card">
			<div class="field">
				<label for="origin">Starting address</label>
				<input id="origin" type="text" placeholder="e.g., 600 Grant St, Pittsburgh, PA">
			</div>
			<div class="field">
				<label for="service">Primary service</label>
				<input id="service" type="text" placeholder="e.g., plumber, dentist, pizza">
				<div class="subtle">What type of service are you interested in?</div>
			</div>
			<div class="field">
				<label for="cities">Cities to check (one per line)</label>
				<textarea id="cities" placeholder="e.g.
Dormont, PA
Mt. Lebanon, PA
Coraopolis, PA
Wexford, PA"></textarea>
				<div class="subtle">Tips: Include state for best accuracy. You can paste a CSV column.</div>
			</div>
			<div class="field">
				<label for="radius">Radius (miles)</label>
				<select id="radius">
					<option value="5">5 miles</option>
					<option value="10" selected>10 miles</option>
					<option value="15">15 miles</option>
					<option value="20">20 miles</option>
					<option value="30">30 miles</option>
				</select>
			</div>
			<div class="actions">
				<button id="runBtn">Verify and Map</button>
				<button id="clearBtn" class="secondary" type="button">Clear</button>
				<span id="status" class="subtle"></span>
			</div>
			<div class="field" style="margin-top:12px">
				<span class="badge" id="summaryBadge">Ready</span>
			</div>
		</section>

		<section class="card">
			<div id="map"></div>
		</section>

		<section class="card" style="grid-column: 1 / -1;">
			<h3 style="margin: 4px 0 10px;">Results</h3>
			<div class="subtle" id="resultsSummary">No results yet.</div>
			<div style="overflow:auto; margin-top:8px;">
				<table id="resultsTable" aria-label="Verification results">
					<thead>
						<tr>
							<th>City</th>
							<th>Resolved Address</th>
							<th>Distance (mi)</th>
							<th>Within Radius?</th>
							<th>Search Volume</th>
							<th>Suggested Replacement</th>
							<th>Replacement Volume</th>
						</tr>
					</thead>
					<tbody></tbody>
					<tfoot>
						<tr><td colspan="7" id="totalsCell"></td></tr>
					</tfoot>
				</table>
			</div>
			<div class="subtle" style="color:#a3312e;">
			  Note: "Search Volume" is the number of matching places for your service term found via Google Maps, <b>not the true monthly search volume</b>. For true search volume, use a keyword research tool.
			</div>
		</section>

		<!-- Placement checker -->
		<section class="card" style="grid-column: 1 / -1; margin-top: 24px;">
		  <h3 style="margin: 4px 0 10px;">Check Your Business Placement</h3>
		  <div class="field">
			<label for="placement-business">Business Name or Google Profile Link</label>
			<input id="placement-business" type="text" placeholder="e.g., Vibe Esthetics or https://g.co/kgs/xxxxxx">
		  </div>
		  <div class="field">
			<label for="placement-keyword">Search Term (e.g., botox)</label>
			<input id="placement-keyword" type="text" placeholder="e.g., botox">
		  </div>
		  <div>
			<button id="placement-btn">Check Current Placement</button>
			<span id="placement-status" class="subtle"></span>
		  </div>
		  <div style="margin-top:12px;">
			<span id="placement-result"></span>
		  </div>
		</section>

		<!-- Place ID Extractor -->
		<section class="card" style="grid-column: 1 / -1; margin-top: 24px;">
		  <h3 style="margin:4px 0 10px;">Extract Place ID from Google Maps Link</h3>
		  <div class="field">
			<label for="extract-link">Paste Google Maps Profile Link</label>
			<input id="extract-link" type="text" placeholder="e.g., https://maps.app.goo.gl/abc123 or https://g.co/kgs/xyz789">
		  </div>
		  <div>
			<button id="extract-placeid-btn">Extract Place ID</button>
			<span id="extract-status" class="subtle"></span>
		  </div>
		  <div style="margin-top:12px;">
			<span id="placeid-result" style="font-weight:bold;"></span>
		  </div>
		</section>
	</main>

	<script>
		const toRad = d => d * Math.PI / 180;
		function haversineMiles(lat1, lon1, lat2, lon2) {
			const R = 3958.7613;
			const dLat = toRad(lat2 - lat1);
			const dLon = toRad(lon2 - lon1);
			const a = Math.sin(dLat/2) ** 2 +
				Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon/2) ** 2;
			const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
			return R * c;
		}

		const originEl = document.getElementById('origin');
		const serviceEl = document.getElementById('service');
		const citiesEl = document.getElementById('cities');
		const radiusEl = document.getElementById('radius');
		const runBtn = document.getElementById('runBtn');
		const clearBtn = document.getElementById('clearBtn');
		const statusEl = document.getElementById('status');
		const resultsSummaryEl = document.getElementById('resultsSummary');
		const resultsTableBody = document.querySelector('#resultsTable tbody');
		const totalsCell = document.getElementById('totalsCell');
		const summaryBadge = document.getElementById('summaryBadge');

		let map, originMarker, radiusCircle;
		let markers = [];

		function initMap() {
			map = new google.maps.Map(document.getElementById('map'), {
				center: { lat: 39.8283, lng: -98.5795 },
				zoom: 4,
				mapTypeControl: false,
				streetViewControl: false
			});
		}
		window.initMap = initMap;

		function setStatus(msg, spinning = false) {
			statusEl.innerHTML = spinning ? '<span class="spinner"></span> ' + msg : msg;
		}

		function clearMap() {
			if (originMarker) { originMarker.setMap(null); originMarker = null; }
			if (radiusCircle) { radiusCircle.setMap(null); radiusCircle = null; }
			markers.forEach(m => m.setMap(null));
			markers = [];
		}

		function clearResults() {
			resultsTableBody.innerHTML = '';
			resultsSummaryEl.textContent = 'No results yet.';
			totalsCell.textContent = '';
			summaryBadge.textContent = 'Ready';
			summaryBadge.className = 'badge';
		}

		clearBtn.addEventListener('click', () => {
			originEl.value = '';
			serviceEl.value = '';
			citiesEl.value = '';
			radiusEl.value = '10';
			clearMap();
			clearResults();
			setStatus('');
		});

		function geocodeAddress(address) {
			const geocoder = new google.maps.Geocoder();
			return new Promise((resolve, reject) => {
				geocoder.geocode({ address }, (results, status) => {
					if (status === 'OK' && results && results.length) {
						const r = results[0];
						resolve({
							lat: r.geometry.location.lat(),
							lng: r.geometry.location.lng(),
							formatted: r.formatted_address,
							placeId: r.place_id
						});
					} else {
						reject(new Error(status || 'No results'));
					}
				});
			});
		}

		function drawOriginAndRadius(originLatLng, miles) {
			originMarker = new google.maps.Marker({
				position: originLatLng,
				map,
				title: 'Origin'
			});
			const meters = miles * 1609.344;
			radiusCircle = new google.maps.Circle({
				strokeColor: '#e11d48',
				strokeOpacity: 0.9,
				strokeWeight: 1.5,
				fillColor: '#fda4af',
				fillOpacity: 0.25,
				map,
				center: originLatLng,
				radius: meters
			});
			const bounds = radiusCircle.getBounds();
			if (bounds) {
				map.fitBounds(bounds, 60);
			} else {
				map.setCenter(originLatLng);
				map.setZoom(12);
			}
		}

		function addCityMarker(latLng, title, within) {
			const marker = new google.maps.Marker({
				position: latLng,
				map,
				title,
				icon: within ? undefined : {
					path: google.maps.SymbolPath.CIRCLE,
					scale: 6,
					fillColor: '#dc2626',
					fillOpacity: 1,
					strokeColor: '#7f1d1d',
					strokeWeight: 1
				}
			});
			markers.push(marker);
			return marker;
		}

		function parseCitiesInput(text) {
			return text.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
		}

		function updateSummaryBadge(allWithin, hasAny) {
			if (!hasAny) {
				summaryBadge.textContent = 'No results';
				summaryBadge.className = 'badge';
				return;
			}
			if (allWithin) {
				summaryBadge.textContent = 'All within radius';
				summaryBadge.className = 'badge ok';
			} else {
				summaryBadge.textContent = 'Some outside radius';
				summaryBadge.className = 'badge no';
			}
		}

		function getServiceVolumeForCity(city, service) {
			return new Promise(resolve => {
				const serviceObj = new google.maps.places.PlacesService(map);
				const query = `${service} in ${city.formatted}`;
				serviceObj.textSearch({
					location: { lat: city.lat, lng: city.lng },
					radius: 10000,
					query: query
				}, (svcResults, svcStatus) => {
					if (svcStatus === google.maps.places.PlacesServiceStatus.OK && svcResults) {
						resolve(svcResults.length);
					} else {
						resolve(0);
					}
				});
			});
		}

		async function getSuggestedReplacements(origin, radiusMiles, service, inputCities, n) {
			return new Promise((resolve) => {
				const serviceObj = new google.maps.places.PlacesService(map);
				const request = {
					location: { lat: origin.lat, lng: origin.lng },
					radius: radiusMiles * 1609.344,
					keyword: service
				};
				serviceObj.textSearch(request, async (results, status) => {
					let suggestions = [];
					if (status === google.maps.places.PlacesServiceStatus.OK && results && results.length) {
						for (let r of results) {
							const name = (r.name || '').trim();
							const addr = (r.formatted_address || r.vicinity || '').trim();
							const display = name + (addr && !name.includes(addr) ? ', ' + addr : '');
							// Exclude any that match the original input cities (by name or by full address)
							if (inputCities.find(c => 
								(display && (display.toLowerCase().includes(c.input.toLowerCase()) || (c.formatted && display.toLowerCase().includes(c.formatted.toLowerCase()))))
							)) continue;
							// Exclude duplicates
							if (suggestions.find(s => s.display === display)) continue;
							// Get volume (for text search, always 1 for each place, but for demo we use the number of matches)
							suggestions.push({ display, volume: 1 });
							if (suggestions.length >= n) break;
						}
					}
					resolve(suggestions);
				});
			});
		}

		runBtn.addEventListener('click', async () => {
			const originAddr = originEl.value.trim();
			const service = serviceEl.value.trim();
			const cityLines = parseCitiesInput(citiesEl.value);
			const radiusMiles = parseFloat(radiusEl.value);

			if (!originAddr) { alert('Please enter a starting address.'); return; }
			if (!service) { alert('Please enter a primary service.'); return; }
			if (!cityLines.length) { alert('Please enter at least one city.'); return; }

			setStatus('Geocoding origin…', true);
			runBtn.disabled = true;

			try {
				clearMap();
				clearResults();

				const origin = await geocodeAddress(originAddr);
				const originLL = { lat: origin.lat, lng: origin.lng };

				drawOriginAndRadius(originLL, radiusMiles);

				setStatus('Geocoding cities…', true);
				const concurrency = 5;
				const queue = [...cityLines];
				const cityRecords = [];
				let active = 0;

				await new Promise((resolve) => {
					const next = () => {
						if (!queue.length && active === 0) return resolve();
						while (active < concurrency && queue.length) {
							const city = queue.shift();
							active++;
							geocodeAddress(city)
								.then(loc => {
									const dist = haversineMiles(origin.lat, origin.lng, loc.lat, loc.lng);
									cityRecords.push({
										input: city,
										formatted: loc.formatted,
										lat: loc.lat, lng: loc.lng,
										distance: dist,
										within: dist <= radiusMiles,
										error: null,
										volume: null // will fill in below
									});
								})
								.catch(err => {
									cityRecords.push({
										input: city,
										formatted: '',
										lat: null, lng: null,
										distance: null,
										within: false,
										error: err.message || 'Geocoding failed',
										volume: null
									});
								})
								.finally(() => { active--; next(); });
						}
					};
					next();
				});

				// Get search volumes for each valid city
				setStatus('Getting service search volumes…', true);

				await Promise.all(cityRecords.map(async city => {
					if (!city.error) {
						city.volume = await getServiceVolumeForCity(city, service);
					}
				}));

				const outsideCities = cityRecords.filter(c => !c.error && !c.within);

				// Get replacement suggestions for each outside city (unique, not in input list)
				let replacements = [];
				if (outsideCities.length > 0) {
					setStatus('Finding suggested replacements…', true);
					replacements = await getSuggestedReplacements(
						origin, radiusMiles, service, cityRecords, outsideCities.length
					);
				}

				// Render table
				let withinCount = 0, outsideCount = 0, errorCount = 0;
				let replacementIdx = 0;
				for (const city of cityRecords) {
					const tr = document.createElement('tr');
					let suggestCell = document.createElement('td');
					let suggestVolCell = document.createElement('td');

					if (city.error) {
						tr.innerHTML = `<td>${city.input}</td>
							<td colspan="2" class="row-error">${city.error}</td>
							<td><span class="badge no">N/A</span></td>
							<td>N/A</td>
							<td>N/A</td>`;
						suggestCell.textContent = '';
						suggestVolCell.textContent = '';
						tr.appendChild(suggestCell);
						tr.appendChild(suggestVolCell);
						errorCount++;
					} else {
						addCityMarker({lat: city.lat, lng: city.lng}, city.formatted, city.within);
						const distStr = city.distance.toFixed(2);
						tr.innerHTML = `<td>${city.input}</td>
							<td>${city.formatted}</td>
							<td>${distStr}</td>
							<td>${city.within ? '<span class="badge ok">Yes</span>' : '<span class="badge no">No</span>'}</td>
							<td>${city.volume}</td>`;

						if (city.within) {
							suggestCell.textContent = '-';
							suggestVolCell.textContent = '-';
							withinCount++;
						} else {
							if (replacements[replacementIdx]) {
								const suggested = replacements[replacementIdx];
								suggestCell.textContent = suggested.display;
								suggestVolCell.textContent = suggested.volume;
								replacementIdx++;
							} else {
								suggestCell.textContent = 'No available replacement';
								suggestVolCell.textContent = '';
							}
							outsideCount++;
						}
						tr.appendChild(suggestCell);
						tr.appendChild(suggestVolCell);
					}
					resultsTableBody.appendChild(tr);
				}

				const allWithin = outsideCount === 0 && errorCount === 0 && cityRecords.length > 0;
				updateSummaryBadge(allWithin, cityRecords.length > 0);

				resultsSummaryEl.textContent = allWithin
					? `All ${withinCount} cities are within ${radiusMiles} miles.`
					: `Within: ${withinCount}. Outside: ${outsideCount}. Errors: ${errorCount}.`;

				totalsCell.textContent = `Total processed: ${cityRecords.length}. Radius: ${radiusMiles} miles. Origin: ${origin.formatted}.`;

				setStatus('Done.', false);
			} catch (e) {
				console.error(e);
				setStatus('Failed. See console for details.');
				alert('Error: ' + (e.message || e));
			} finally {
				runBtn.disabled = false;
			}
		});

		// Placement checker
		document.getElementById('placement-btn').addEventListener('click', async function() {
		  const businessInput = document.getElementById('placement-business').value.trim();
		  const keywordInput = document.getElementById('placement-keyword').value.trim();
		  const originAddr = originEl.value.trim();
		  const radiusMiles = parseFloat(radiusEl.value);
		  const placementStatus = document.getElementById('placement-status');
		  const placementResult = document.getElementById('placement-result');

		  placementStatus.textContent = '';
		  placementResult.textContent = '';

		  if (!originAddr) { alert('Please enter a starting address (origin) above.'); return; }
		  if (!businessInput) { alert('Please enter your business name or profile link.'); return; }
		  if (!keywordInput) { alert('Please enter the search term.'); return; }

		  placementStatus.innerHTML = '<span class="spinner"></span> Searching...';

		  try {
			const origin = await geocodeAddress(originAddr);

			const serviceObj = new google.maps.places.PlacesService(map);
			const request = {
			  location: { lat: origin.lat, lng: origin.lng },
			  radius: radiusMiles * 1609.344,
			  query: keywordInput
			};

			serviceObj.textSearch(request, (results, status) => {
			  placementStatus.textContent = '';
			  if (status === google.maps.places.PlacesServiceStatus.OK && results && results.length) {
				let foundIdx = -1;
				let normalizedBusiness = businessInput.toLowerCase().trim();

				let matchPlaceId = null;
				const placeIdMatch = businessInput.match(/placeid=([^&]+)/i);
				if (placeIdMatch) matchPlaceId = placeIdMatch[1];

				for (let i = 0; i < results.length; i++) {
				  const r = results[i];
				  if (matchPlaceId && r.place_id === matchPlaceId) {
					foundIdx = i;
					break;
				  }
				  if (r.name && r.name.toLowerCase().includes(normalizedBusiness)) {
					foundIdx = i;
					break;
				  }
				  if (r.formatted_address && r.formatted_address.toLowerCase().includes(normalizedBusiness)) {
					foundIdx = i;
					break;
				  }
				}

				if (foundIdx !== -1) {
				  const found = results[foundIdx];
				  placementResult.innerHTML = `
					<b>${found.name}</b> appears at <b>position #${foundIdx + 1}</b> for "<b>${keywordInput}</b>" within ${radiusMiles} miles.<br>
					Address: ${found.formatted_address || found.vicinity || 'N/A'}<br>
					Rating: ${found.rating || 'N/A'}
				  `;
				} else {
				  placementResult.textContent = `Your business was not found in the top ${results.length} results for "${keywordInput}" within ${radiusMiles} miles.`;
				}
			  } else {
				placementResult.textContent = `No results found for "${keywordInput}" within ${radiusMiles} miles.`;
			  }
			});
		  } catch (e) {
			placementStatus.textContent = '';
			placementResult.textContent = 'Error: ' + (e.message || e);
		  }
		});

		// Place ID extractor
		document.getElementById('extract-placeid-btn').addEventListener('click', async function() {
		  const link = document.getElementById('extract-link').value.trim();
		  const status = document.getElementById('extract-status');
		  const result = document.getElementById('placeid-result');
		  status.textContent = '';
		  result.textContent = '';

		  if (!link) {
			status.textContent = "Please enter a Google Maps profile link.";
			return;
		  }

		  // Try to extract placeid= from URL (if present)
		  const placeIdMatch = link.match(/placeid=([^&]+)/i);
		  if (placeIdMatch) {
			result.textContent = "Place ID: " + placeIdMatch[1];
			return;
		  }

		  // If not found, fallback: Use Places API to resolve the link to a Place ID
		  status.innerHTML = '<span class="spinner"></span> Looking up Place ID...';

		  const service = new google.maps.places.PlacesService(map);
		  service.findPlaceFromQuery({
			query: link,
			fields: ['place_id', 'name']
		  }, (results, statusCode) => {
			status.textContent = '';
			if (statusCode === google.maps.places.PlacesServiceStatus.OK && results && results.length) {
			  result.textContent = "Place ID: " + results[0].place_id + " (" + results[0].name + ")";
			} else {
			  result.textContent = "Could not extract Place ID. Please check the link.";
			}
		  });
		});
	</script>
	<script>
		window.GMAPS_KEY = 'AIzaSyArCDaKE-CPhfAZlrAEQidOgD_rfFJ_rqE';
	</script>
	<script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyArCDaKE-CPhfAZlrAEQidOgD_rfFJ_rqE&callback=initMap&libraries=places"></script>
</body>
</html>
